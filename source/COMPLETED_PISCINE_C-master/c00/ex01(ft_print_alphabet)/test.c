/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: evgenkarlson <RTFM@42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/02/14 12:33:14 by evgenkarlson      #+#    #+#             */
/*   Updated: 2020/10/07 21:21:53 by evgenkarlson     ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*         команда для компиляции и одновременного запуска                    */
/*                                                                            */
/*  gcc -Wall -Werror -Wextra test.c && chmod +x ./a.out && ./a.out           */
/* ************************************************************************** */


#include <unistd.h>				/* Эта библиотека требуется для использования функции write */

/*
** Функция write имеет следующие параметры (<дескриптор.потока>, <&указатель на буфер>, <число.записыв.байтов>):
**
** 1. int <дескриптор(идентификатор) потока ввода/вывода>:
** 0	stdin	– стандартное устройство ввода (клавиатура);
** 1	stdout	– стандартное устройство вывода (экран);
** 2	stderr	– стандартное устройство вывода сообщения об ошибках (также экран).
** Простыми словами при открытии файла операционная система создает запись для представления этого файла
** и сохраняет информацию об этом открывшемся файле. Итак, если в вашей ОС открыто 100 файлов, то в ОС
** будет находиться 100 записей (где-то в ядре). Эти записи представлены целыми числами типа (... 100, 101, 102....).
** Этот номер записи является файловым дескриптором. Таким образом, это просто целое число, которое уникально
** представляет собой открытый файл в операционной системе. Если ваш процесс откроет 10 файлов, ваша таблица процессов
** будет содержать 10 записей для дескрипторов файлов.
** Еще простыми словами: чтобы попасть в город (прочитать/записать в файл) мы едем через мост (дескриптор).
**
** 2. const void *buf <указатель на буфер> - адрес, куда мы будем записывать наши данные (байты) и возращать их.
** Значение из ft_putchar(char c(отсюда)) передав его в write(1, &c(cюда), 1).
** Синтаксис, когда мы делаем ссылку на адрес с → &c.
**
** 3. size_t count <число записываемых байтов> - количество пересылаемых данных (1 byte - 1 char).
** Эта функция записывает один символ в стандартный поток вывода терминала.
*/


void	ft_putchar(char c)			/* Определяем функцию для печати символа */
{
	write(1, &c, 1);				/* Вызываем функцию 'write'(системный вызов) отправляя ей в аргументы идетификатор 
									** стандартного потока вывода, котрый будет использован для отправки туда символа на печать.
									** Далее мы используем оператор взятия адреса '&', чтобы мы могли взять адресс переменной 'c' 
									** и отправить этот в функцию 'write' для печати содержимого переменной на которую указывает 
									** этот адресс. 
									** В последнем аргументе функции 'write' мы указываем то на сколько байт в право от добытого 
									** нами адреса нужно продвинуться и сколько считать данных, чтобы их отправить на печать через
									** стандартный поток вывода используя его идентификатор(файловый дескриптор) который мы указали
									** в первом аргументе функции 'write' */
}


void	ft_print_alphabet(void)		/* Определяем функцию для печати алфавита */
{
	char	letter;					/* Обьявляем перменную для хранения символа(вернее для хранения ascii кода символа) */

	letter = 'a';					/* Инициализируем переменную символом 'a' ('ascii' код символа 'a' - целое число 97) */
	while (letter <= 'z')			/* Запускаем цикл который будет печатать содержимое перменной 'letter' и увеличивать 
									** после этого 'ascii' код символа, чтобы указать на символ идущий следующим после него
									** в таблице 'ascii' */
	{
		ft_putchar(letter);			/* вызываем функцию печати символа отправляя ей в аргумент символ 'a'(вернее 'ascii' 
									** код символа 'a'), для печати этого символа */
		letter++;					/* Увеличиваем число отражающее 'ascii' код символа, чтобы указать на символ идущий 
									** следующим после него в таблице 'ascii' */
	}
}


int		main(void)					/* Определяем основную функцию, с которой начнется выполнение программы */
{	
	ft_print_alphabet();			/* Вызываем функцию печати алфавита. В скобкках функции при вызове мы не пишем ничего,
									** оставляя их пустыми т.к. мы помним что функция 'ft_print_alphabet' не принимает в 
									** аргументах ничего */
	return (0);						/* Завершаем функцию и возвращаем ноль */
}
