/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: evgenkarlson <RTFM@42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/05/12 12:33:14 by evgenkarlson      #+#    #+#             */
/*   Updated: 2020/10/19 13:37:31 by evgenkarlson     ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*         команда для компиляции и одновременного запуска                    */
/*                                                                            */
/*  gcc -Wall -Werror -Wextra test.c && chmod +x ./a.out && ./a.out           */
/* ************************************************************************** */


#include <unistd.h>
#include <stdlib.h>
#include "ft_stock_str.h"

/* ************************************************************************** */
/* ************************************************************************** */

void				ft_putchar(char c)/* функция вывода символа */
{
	write(1, &c, 1);
}

/* ************************************************************************** */
/* ************************************************************************** */

void				ft_putstr(char *str)/* Функция печати строки */
{
	while(*str)
		ft_putchar(*str++);
}

/* ************************************************************************** */
/* ************************************************************************** */

void				ft_putnbr(int nb)	/* Функция печати числа */
{
	int	temp;
	int	size;

	size = 1;
	if (nb < 0)
	{
		ft_putchar('-');
		nb = -nb;
	}
	if (nb == -2147483648)
	{	
		ft_putchar('2');
		nb = 147483648;
	}
	temp = nb;
	while ((temp /= 10) > 0)
		size *= 10;
	temp = nb;
	while (size)
	{
		ft_putchar((char)((temp / size)) + 48);
		temp %= size;
		size /= 10;
	}
}

/* ************************************************************************** */
/* ************************************************************************** */

void				ft_show_tab(struct s_stock_str *par)/* Функция печати структуры. Печать будет в таком порядке: строка, размер, копия строки */
{
	int	i;							/* Обьявляем переменную для счетчика чтобы перемечаться по экземплярам структур */

	i = 0;							/* Инициализируем счетчик нулем, чтобы начать работать с нулевой ячейки хранящей адресс самого первого экземпляра */
	while (par[i].str)				/* Если в текущей ячейке массива экземпляров структур у этого экземпляра хранится слово то запускаем цикл печатающий все его элементы */ 
	{
		ft_putstr(par[i].str);		/* Печатаем строку , адрес которой  в указателе "str" */
		ft_putchar('\n');			/* Печатаем символ перехода на новую строку */
		ft_putnbr(par[i].size);		/* Печатаем число отображающее количество символов в строке "str" */
		ft_putchar('\n');			/* Печатаем символ перехода на новую строку */
		ft_putstr(par[i].copy);		/* Печатаем дубликат строки "str", адрес которой хранится в указателе "copy" */
		ft_putchar('\n');			/* Печатаем символ перехода на новую строку */
		i++;						/* Увеличиваем счетчик переходя к след ячейке массива экземпляров структур типа t_stock_str"(struct s_stock_str)*/
	}
}

/* ************************************************************************** */
/* ************************************************************************** */

struct s_stock_str	*ft_strs_to_tab(int ac, char **av)	/* Функция принимает в аргументах целое число с количеством строк, адресс массива строк(массивов символов), и
								** разбирает каждую строку массива строк на состовляющие(сохраняет размер строки, делает копию строки, получает размер строки), а потом сохраняет получены 
								** данные по экземплярам и в самом конце возвращает сам адрес массива с экземплярами структуры "struct s_stock_str" */
{
	int			i;				/* Обьявляем переменную для счетчика, чтобы перемечаться по экземплярам структур и строкам массива строк "av" */
	int			j;				/* Обьявляем переменную для счетчика, которую используем для подсчета выбранной строки и для перемещения по символам выбраной строки */
	t_stock_str	*ret;			/* Создаем указатель на экземпляр структуры "t_stock_str"(struct s_stock_str), который будет хранить адрес выделеной памяти */

	if ((ret = (t_stock_str *)malloc(sizeof(t_stock_str) * (ac + 1))) == ((void *)0))/* выделяем память типа "t_stock_str"(struct s_stock_str) под массив экземпляров 
								** на столько же экземпляров сколько у нас строк храниться в массиве строк "av" и плюс один для завершающего нуля */
		return ((void *)0);		/* Если что то пошло не так то возвращаем указатель типа NULL и завершаем функцию */
	i = 0;						/* Инициализируем счетчик i нулем чтобы начать разбор каждой строки массива строк на состовляющие части с нулевой ячейки и записывать 
								** извлеченные данные в экземпляры структуры типа "t_stock_str"(struct s_stock_str) начиная с нулевого экземпляра */
	while (i < ac)				/* Запускаем цикл который разберет каждую строку из массива строк и заполнит этим каждый экземпляр типа t_stock_str"(struct s_stock_str) */
	{
		j = 0;					/* Инициализируем 'j' нулем для подсчета туда количества символов текущей строки*/
		while (av[i][j])		/* Запускаем цикл подсчета количества симолов в текущей строке */
			j++;
		ret[i].size = j;		/* Сохраняем найденое количество символов в переменной "size" текущего экземпляра типа t_stock_str"(struct s_stock_str) */
		ret[i].str = av[i];		/* Сохраняем адрес текущей строки в указателе "str" текущего экземпляра типа t_stock_str"(struct s_stock_str) */
		if((ret[i].copy = (char *)malloc(sizeof(char) * (ret[i].size + 1))) == ((void *)0))/* Выделяем память для копирования текущей строки и сохраняем адресс 
								** выделеной памяти в указателе "copy" текущего экземпляра типа t_stock_str"(struct s_stock_str) */
			return ((void *)0);	/* Если что то пошло не так то возвращаем указатель типа NULL и завершаем функцию */
		j = 0;					/* Записываем ноль в перменную 'j' для использования её как счетчика при копировании текущей строки в выделеную память */
		while (j < ret[i].size)	/* Запускаем цикл, который скопирует текущую строку в выделеную для нее память */
		{
			ret[i].copy[j] = av[i][j];/* Копируем каждый символ из текущей строки в выделеную память */
			j++;					  /* увеличиваем счетчик для перехода к след ячейке с символом */
		}
		ret[i].copy[j] = '\0';	/* после создания дубликата строки в конце добавляем завершающий символ нуля */
		i++;					/* увеличиваем счетчик для перехода к след экземпляру типа t_stock_str"(struct s_stock_str) */
	}
	ret[i].str = ((void *)0);	/* Сохраняем "нулевой указатель" в указателе "str" последнего экземпляра типа t_stock_str"(struct s_stock_str) как символ того что этот
								** экземпляр пустой и создан как */ 
	return (ret);				/* Возвращаем адрес нулевого экземпляра полученых и завершаем функцию */
}

/* ************************************************************************** */
/* ************************************************************************** */

int    				 main(void)	/* Основаная функция */
{
	char	*arr_str[4] = {"строка", "еще одна строка", "последняя строка"};/* Обьявляем массив указателей, в который мы сохраним адреса строк.
								** Когда мы помещаем строки в массив указателей, при компиляции, их места занимают адреса из памяти, по которым они будут распложены. */

	struct s_stock_str *a;		/* Создаем указатель на экземпляр структуры типа t_stock_str"(struct s_stock_str) */
	a = ft_strs_to_tab(3, arr_str);/* Отправляем в аргументы функции - число с отображающее количество строк и адресс массива со строками */
	ft_show_tab(a);				/* Печатаем полученый в указатель адресс массива экземпляров типа t_stock_str"(struct s_stock_str) содержащий аргументы программы 
								** разложеные на составляющие */

	return (0);					/* Возвращаем ноль и завершаем программу */
}