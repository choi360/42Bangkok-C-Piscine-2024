/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_hexdump.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: evgenkarlson <RTFM@42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/02/14 12:33:14 by evgenkarlson      #+#    #+#             */
/*   Updated: 2020/11/07 23:45:06 by evgenkarlson     ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


#include "../includes/ft_lib.h"

#define BASE_TYPE 16					/* Определяет идентификатор и последовательность символов, которая будет за­мещаться
										** данным идентификатором при его обнаружении в тексте программы.
										** Записываем на то место, где должна быть последовательность символов, число, отражающее
										** базовый тип шестнадцатиричной системы счисления */

/* Функция печати адреса первого символа строки */
void ft_print_address(int nbr, char *hex)	/* Принимает в параметры число указывающее порядковый номер адреса относительно начала
											** и адрес строки с символами нужной нам системы счисления */
{
	int		add[9];											
	int 	i;							/* обьявляем счетчик для подсчета количества найденых символов*/
	int		j;							/* обьявляем переменную для вычисления значения показывающего сколько раз нужно печатать символ нуля перед самим адресом */

	i = 0;								/* инициализируем счетчик найденых символов нулем */
	j = 8;								/* инициализируем счетчик заполнения пустых ячеек числом 0 на случай если адресс равен нулю */
	if(nbr == 0)						/* Если порядковый номер указывающий на адресс равен нулю */
	{
		while(j-- > 0)					/* Значит запускаем цикл печатающий 8 символов и завершаем функцию */
			ft_putchar('0');
	}
	else
	{
		while (nbr)						/* пока значение переменной хранящей число не равно нулю */
		{
			add[i] = nbr % BASE_TYPE;	/* ВЫЧИСЛЯЕМ с помощью base_size ТО, как в нужной нам системе счисления выглядит число.
										** Для этого делим nbr на base_size по модулю и записывая результат в массив начиная с первой ячейки.
										** Так мы узнаем значение крайнего символа в нужной нам системе счисления */

			nbr /= BASE_TYPE;			/* Теперь для вычисления оставшихся чисел уменьшаем само число в nbr, разделив его на 
										** размер base_size (размер нужного нам базового типа) и сохраняем результат в той же переменной nbr */

			i++;						/* Увеличиваем счетчик для перехода к след ячейке. Так же переменная i нам понадобиться позже. 
										** Накопленное в ней значение скажет нам о размере получившегося массива, которое мы используем 
										** чтобы напечатать символы в правильном порядке. */
		}
		j = (8 - i);					/* узнаем сколько еще осталось места в выводе где должны быть напечатаны симолы */
		while(j-- > 0)					/* Запускаем цикл заполяющий нулями пустые места, которые должны быть заняты или числом или нулями */
			ft_putchar('0');
		while (i > 0)					/* Запускаем цикл который напечатает все найденные нами и записанные в массив 'add' значения символов начиная с конца */
			ft_putchar(hex[add[--i]]);	/* Для этого мы используем массив с каждым найденным нами числом, как указатель на ячеку массива в котрой храниться его значение.
										** Вызывать числа из массива 'add' и вставлять как указательна нужное значение мы будем в обратном порядке.
										** Начиная с конца массива и двигаясь к его началу, чтобы восстановить порядок найденых нами символов */
	}
	ft_putchar(' ');					/* После печати адреса в hex печатаем двоеточие */
	ft_putchar(' ');					/* И пробел, и завершаем функцию  */
}


/* Функция печати строки в hex формате */
void	ft_print_hex(int i, unsigned int size, unsigned char *p, char *hex)/* Принимает позицию нужного нам первого символа, предел печати, 
										** адресс строки с которой будем работать и адрес строки с символами нужной нам системы счисления */
{
	unsigned int	j;					/* обьявляем счетчик отмеряющий пройденые символы */

	j = 0;								/* Инициализируем счетчик нулем чтобы начать печать символов с нулевой позици(относително переменной 'i') */
	while ((j < 16) && (i + j < size))	/* Запускаем цикл печати строки в hex формате. Её длинна должна быть не больше 16 символов и не должна выходить за рамки "size" */
	{
										/* Высчитаваем индекс нужной нам ячейки массива чтобы получить символ и разбив его на две части получить его 
										** шестнадцатиричное значение. Да, мы разберем 8 битный символ на две половины т.к нужная нам шестнадцатиричная
										** система стостоит из 4 битных значений */
		ft_putchar((char)hex[(*(p + i + j) / BASE_TYPE) % BASE_TYPE]);	/* Тут вычитываем шестнадцатиричное значение левой половины нужного нам символа */
		ft_putchar((char)hex[*(p + i + j) % BASE_TYPE]);				/* Тут вычитываем шестнадцатиричное значение правой половины нужного нам символа */									
		ft_putchar(' ');
		if(j == 7)
			ft_putchar(' ');
		j++;
	}
	if(j <= 7)
		ft_putchar(' ');
	while (j < 16)						/* Если j по прежнему меньше 16 значит мы достигли предела печати символов а место еще осталось и мы заполняем оставшееся пробелами */
	{
		ft_putstr("   ");
		j++;
	}
	ft_putchar(' ');
}


/* Функция печати строки длинной в 16 символов */
void	ft_print_char(int i, unsigned int size, unsigned char *p)/* Принимает позицию нужного нам первого символа, предел печати и адресс строки с которой будем работать */
{	
	unsigned int	j;											/* обьявляем счетчик отмеряющий пройденые символы */

	j = 0;
	ft_putchar('|');
	while ((j < 16) && (i + j < size))							/* Запускаем цикл печати той же строки что и выше но уже в стандартном формате 
																** Её длинна должна быть не больше 16 символов */
	{
		if (*(p + i + j) >= 32 && *(p + i + j) <= 126)			/* Если символ являеться печатаемым */
			ft_putchar((char)*(p + i + j));						/* ТО печатаем его */
		else
			ft_putchar('.');									/* Если символ не печатаемый то печатаем вместо него точку */
		j++;													/* переходим к след ячейке массива символов(строки) */
	}
	ft_putchar('|');
}

/* Функция печати нужного участка памяти, нужной длинны */
void	ft_hexdump(int argc, char **argv)	/* Принимаем в 'argc' количество строк, и адресс массива строк в '**argv' */
{
	int					j;					/* Обьявляем счетчик который будет хранить количество напечатанных символов */
	int					r;
	char				hex[] = "0123456789abcdef";/* Обьявляем указатель который будет хранить адресс строки с данными о нужной нам системы счисления */
	unsigned char		buffer[17];			/* Обьявляем массив для хранния порции симолов считанных из файла */
	int					fd;					/* Обьявляем переменную которая будет хранить идентификатор файлового потока(дескриптор файла) нашего файла.
											** (Файловый дескриптор — это неотрицательное число, которое является идентификатором
											** какого-либо потока ввода-вывода, который может быть связан с файлами, каталогами или сокетами.
											** Сами дескрипторы файлов привязаны к идентификатору процесса. Самые известные файловые дескрипторы - это 0, 1, 2.
											** Нулю соответствует STDIN(стандартный поток ввода), еденице соответствует STDOUT(стандартный поток вывода),
											** а двойке соответствует STDERR(стандартный поток ошибок). У каждой програмы есть все три этих системных потока.) */

	if (argc > 1 && (argv[1][0] == '-') && (argv[1][1] == 'C'))
	{
		j = 0;											/* Инициализируем нулем счетчик который считать количество напечатанных символов */
		g_progname = basename(*argv);
		argv = argv + 2;
		while (argc > 2)								/* Запускаем цикл с каждой итерацией которого мы печатаем новую строку */
		{
			if ((fd = open(*argv, O_RDONLY)) == -1)		/* Отправляем в функцию 'open' строку с именем и путем до файла, а также флаг 'O_RDONLY'.
														** Благодраря пути до файла и флагу 'O_RDONLY' функция сразу из условия откроет поток для чтения из 
														** файла и вернет нам идентификатор этого потока (файловый дескриптор) который мы сохраним в 'fd' */
			{
				ft_display_custom_error(errno, *argv);
			}
			else
			{
				while ((r = read(fd, buffer, BASE_TYPE)))
				{
					if (r == -1)
					{
						ft_display_custom_error(errno, *argv);
						break;
					}
					ft_print_address(j, hex);			/* Запускаем печать адреса первого символа строки отправлям туда номер позиции первого 
														** символа текущей строки и символы для 'hex'*/
					ft_print_hex(0, r, buffer, hex);	/* Запускаем печать строки в hex. Отправляя туда номер символа с котрого начать конвертирование 
														** и печать, предел печати, адресс строки и адрес строки с символами нужной нам системы счисления */
					ft_print_char(0, r, buffer);		/* Запускаем печать строки в таком виде как она есть. Отправляя туда номер символа с 
														** котрого начать печать, предел печати, адресс строки */
					ft_putchar('\n');					/* Печатаем символ перехода на новую строку  для корректного отображения вывода*/
					j += BASE_TYPE;
				}
				if (close(fd))							/* Закрываем файловый поток с помощью функции 'close' и дескриптора файла(идентификатора файлового потока) */
				{
					ft_display_custom_error(errno, *argv);
				}
			}
			argc--;										/* Уменьшаем значение отображающее количество строк для понимания того сколько строк мы уже прошли */
			argv++;										/* Увеличиваем значение адреса в указателе чтобы перейти к след строке */
		}
		ft_print_address(j, hex);						/* Запускаем печать адреса первого символа строки отправлям туда номер позиции первого 
														** символа текущей строки и символы для 'hex'*/
		ft_putchar('\n');
	}
}