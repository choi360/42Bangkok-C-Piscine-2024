/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   5-0____brainfuck.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: evgenkarlson <RTFM@42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/02/14 12:33:14 by evgenkarlson      #+#    #+#             */
/*   Updated: 2021/02/11 19:05:55 by evgenkarlson     ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/* ************************************************************************** **


Assignment name  : brainfuck
Expected files   : *.c, *.h
Allowed functions: write, malloc, free
--------------------------------------------------------------------------------

Напишите программу интерпретатора "Brainfuck".
Исходный код будет указан в качестве первого параметра.
Код всегда будет действительным, не более 4096 операций.
"Brainfuck" - это минималистский язык. Он состоит из массива байтов(в нашем случае,
скажем, 2048 байтов), инициализированных нулем, и указателя на его первый байт.

Каждый оператор состоит из одного символа:
- '>' увеличить указатель;
- '<' уменьшить указатель;
- '+' увеличить указанный байт;
- '-' уменьшить указанный байт;
- '.' вывести указанный байт на стандартный вывод;
- '[' перейти к соответствующему ']', если указанный байт равен 0 (при запуске);
- ']' перейти к соответствующему '[', если указанный байт не равен 0 (в конце).

Любой другой персонаж - это комментарий.

Примеры:

$>./brainfuck "++++++++++[>+++++++>++++++++++>+++>+<<<<-]
>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>." | cat -e
Hello World!$
$>./brainfuck "+++++[>++++[>++++H>+++++i<<-]>>>++\n<<<<-]>>--------.>+++
++.>." | cat -e
Hi$
$>./brainfuck | cat -e
$


** **************************ПРИМЕР ПРОГРАММЫ******************************** **


https://ru.wikipedia.org/wiki/Brainfuck


$>./brainfuck "++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.
<<+++++++++++++++.>.+++.------.--------.>+.>." | cat -e
Hello World!$
$>


** ***************************РАСШИФРОВКА************************************ **


Цикл набивки основных чисел:
++++++++++          Запишем в ячейке 0 число 10 отражающее количество 
					итераций для цилка, котрый будет повторять описаные
					в квадратных скобках команды.
[                   Квадратная скобка означающаа начало цикла
					Он будет повторять описанные этой скобкой команды,
                    пока значение записанной нами перед скобкой ячейки 0
					не станет равно нулю.
>+++++++            приращение ячейки 1 на 7
>++++++++++         приращение ячейки 2 на 10
>+++                приращение ячейки 3 на 3
>+                  приращение ячейки 4 на 1
<<<<-               декремент ячейки 0 на 1
]                   проверка, не равна ли ячейка 0 нулю

Вывод первого слова:
>++.                в ячейке 1 добавление 2 к 70 и вывод на печать ASCII-кода 72,
					т.е. буквы «Н».
>+.                 в ячейке 2 добавление 1 к 100 = 101, печать буквы «e»
+++++++..           в этой же ячейке добавление 7 к 101 = 108, печать «l» дважды
+++.                в этой же ячейке добавление 3 к 108 = 111, печать «o»
>++.                в ячейке 3 добавление 2 к 30 = 32, печать пробела

Вывод второго слова с повторным использованием ячеек:
<<+++++++++++++++.  в ячейке 1 добавление 15 к 72 = 87, печать «W»
>.                  в ячейке 2 уже есть 111, сразу печать «o»
+++.                в этой же ячейке добавление 3 к 111 = 114, печать «r»
------.             в этой же ячейке вычитание 6 из 114 = 108, печать «l»
--------.           в этой же ячейке вычитание 8 из 108 = 100, печать «d»
>+.                 в ячейке 3 добавление 1 к 32 = 33, печать «!»
>.                  в ячейке 4 уже есть 10, сразу печать перевода строки


** ************************************************************************** */
/* ************************************************************************** */


#include <unistd.h>
#include <stdlib.h>

#define BUFF_SIZE 2048

void	ft_putchar(char c)
{
	write(1, &c, 1);
}

int		find_next(char *str)
{
	int		count;
	int		i;

	i = 1;
	count = 0;
	while (str[i])
	{
		if (str[i] == '[')
			count++;
		else if (str[i] == ']')
		{
			if (count == 0)
				return (i);
			else
				count--;
		}
		i++;
	}
	return (0);
}

int		find_previous(char *str)
{
	int		count;
	int		i;

	i = -1;
	count = 0;
	while (str[i])
	{
		if (str[i] == ']')
			count++;
		else if (str[i] == '[')
		{
			if (count == 0)
				return (i);
			else
				count--;
		}
		i--;
	}
	return (0);
}

int		brainfuck(char *str)
{
	char	*ptr;
	int		c;
	int		p;

	if (!(ptr = (char *)malloc(sizeof(char) * (BUFF_SIZE + 1))))
		return (-1);
	p = 0;
	while (p <= BUFF_SIZE)
		ptr[p++] = '\0';
	p = 0;
	c = 0;
	while (str[c])
	{
		/* changing item */
		if (str[c] == '>')
			p++;
		else if (str[c] == '<')
			p--;
		else if (str[c] == '+')
			ptr[p]++;
		else if (str[c] == '-')
			ptr[p]--;
		else if (str[c] == '.')
			ft_putchar(ptr[p]);

		/* moving */
		if ((str[c] == '[') && !ptr[p])
			c += find_next(str + c);
		else if ((str[c] == ']') && ptr[p])
			c += find_previous(str + c);
		else
			c++;
	}
	free(ptr);
	return (0);
}

int		main(int ac, char **av)
{
	if (ac == 2)
		brainfuck(av[1]);
	else
		ft_putchar('\n');
	return (0);
}
