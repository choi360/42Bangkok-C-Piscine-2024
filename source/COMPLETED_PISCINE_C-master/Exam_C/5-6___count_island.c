/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   5-6___count_island.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: evgenkarlson <RTFM@42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/02/14 12:33:14 by evgenkarlson      #+#    #+#             */
/*   Updated: 2021/03/05 13:37:07 by evgenkarlson     ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/* ************************************************************************** **


Assignment name  : count_island
Expected files   : *.c, *.h
Allowed functions: open, close, read, write, malloc, free
--------------------------------------------------------------------------------

Напишите программу, которая принимает файл, содержащий строки одинаковой длины. 
Эти строки содержат символы, которые либо являются '.' или 'X'. Все эти линии 
вместе образуют прямоугольники из символа '.' содержащие «острова» 'X'.

Максимальный размер строки - 1024 символа, включая завершающую новую строку.

Столбец, если он сформирован из набора символов в файле, которые отделены от 
начала своих соответствующих строк одинаковым количеством символов.

Говорят, что два символа соприкасаются друг с другом, если они смежные и 
находятся в одной строке или в смежных строках и в одном столбце.

«Остров» из «X» означает набор «X», соприкасающихся друг с другом.

Программа должна пройти через файл и отобразить его после замены всех «X» 
числом, соответствующим положению их острова в файле, начиная с начала файла.

Результат может быть только один.

Если файл пуст, или есть ошибка (например, некогерентный ввод), или параметры 
не переданы, программа должна отображать новую строку.

Файл содержит не более 10 островов.

Вы найдете примеры в тематическом каталоге.

Примеры:

$>cat johndoe
.................XXXXXXXX..........................................
....................XXXXXXXXX.......XXXXXXXX.......................
.................XXXXXXXX..............XXX...XXXXX.................
.....................XXXXXX.....X...XXXXXXXXXXX....................
................................X..................................
......XXXXXXXXXXXXX.............X..................................
..................X.............XXXXXXXXX..........................
..................X.........XXXXXXXXXXXX...........................
..................X................................................
XX.............................................................XXXX
XX..................XXXXXXXXXXXXX.................................X
...................................................................
.................................................................X.
.....................XXXXX.......................................XX
$>
$>./count_island johndoe
.................00000000..........................................
....................000000000.......11111111.......................
.................00000000..............111...11111.................
.....................000000.....2...11111111111....................
................................2..................................
......3333333333333.............2..................................
..................3.............222222222..........................
..................3.........222222222222...........................
..................3................................................
44.............................................................5555
44..................6666666666666.................................5
...................................................................
.................................................................7.
.....................88888.......................................77
$>

$>cat who-s-there
...................................................................
...X........X.....XXXXX......XXXXXXX...XXXXXXXXXX..XXXXXXXXXX......
...XX......XX....XX...XX....XX.....XX.....XXXX.....XXXXXXXXXX......
...XXXX..XXXX...XX.....XX...XX.....XX......XX......XX..............
...XX.XXXX.XX...XX.....XX...XX.....XX......XX......XX..............
...XX...X..XX...XX.....XX...XXXXXXXX.......XX......XXXXX...........
...XX......XX...XXXXXXXXX...XXXX...........XX......XXXXX...........
...XX......XX..XX.......XX..XX.XX..........XX......XX..............
...XX......XX..XX.......XX..XX...X.........XX......XX..............
...XX......XX..XX.......XX..XX....X......XXXXXX....XXXXXXXXXX......
...XX......XX.XX.........XX.XX.....XX..XXXXXXXXXX..XXXXXXXXXX..X...
...................................................................
$>
$>./count_island who-s-there
...................................................................
...0........0.....11111......2222222...3333333333..4444444444......
...00......00....11...11....22.....22.....3333.....4444444444......
...0000..0000...11.....11...22.....22......33......44..............
...00.0000.00...11.....11...22.....22......33......44..............
...00...0..00...11.....11...22222222.......33......44444...........
...00......00...111111111...2222...........33......44444...........
...00......00..11.......11..22.22..........33......44..............
...00......00..11.......11..22...5.........33......44..............
...00......00..11.......11..22....6......333333....4444444444......
...00......00.11.........11.22.....77..3333333333..4444444444..8...
...................................................................
$>

$>cat -e void
$>./count_island void | cat -e
$
$>


** ************************************************************************** */
/* ************************************************************************** */



#include <unistd.h>
#include <fcntl.h>

#define LIM 102400

void	flood_fill(char *map, int width, int pos, int size, char replace)
{
	if (pos < 0 || pos >= size || !map[pos] || map[pos] != 'X')
		return ;
	map[pos] = replace;
	flood_fill(map, width, pos + 1, size, replace);            // смещаемся по оси 'x' вперед
	flood_fill(map, width, pos - 1, size, replace);            // смещаемся по оси 'x' назад
	flood_fill(map, width, pos - width, size, replace);        // смещаемся по оси 'y' вниз
	flood_fill(map, width, pos + width, size, replace);        // смещаемся по оси 'y' вверх

/* Дополнительная часть. Здесь закоментирован код, котрый слегка расширяет возможности алгоритма и ищет 
** не только то что соприкосается с островами сверху-снизу или слева-справа но и то что находиться в 
** углах островов

	flood_fill(map, width, pos + width + 1, size, replace);    // смещаемся по оси 'y' вверх и вправо
	flood_fill(map, width, pos + width - 1, size, replace);    // смещаемся по оси 'y' вверх и влево
	flood_fill(map, width, pos - width + 1, size, replace);    // смещаемся по оси 'y' вниз и вправо
	flood_fill(map, width, pos - width - 1, size, replace);    // смещаемся по оси 'y' вниз и влево


** Вывод при использовании стандартной части алгоритма
** (такой результат запрашивает задание!):
...................................................................
...0........0.....11111......2222222...3333333333..4444444444......
...00......00....11...11....22.....22.....3333.....4444444444......
...0000..0000...11.....11...22.....22......33......44..............
...00.0000.00...11.....11...22.....22......33......44..............
...00...0..00...11.....11...22222222.......33......44444...........
...00......00...111111111...2222...........33......44444...........
...00......00..11.......11..22.22..........33......44..............
...00......00..11.......11..22...5.........33......44..............
...00......00..11.......11..22....6......333333....4444444444......
...00......00.11.........11.22.....77..3333333333..4444444444..8...
...................................................................


** А это уже вывод при использовании дополнительной части алгоритма.
** (такой результат задание не просит!):

...................................................................
...0........0.....11111......2222222...3333333333..4444444444......
...00......00....11...11....22.....22.....3333.....4444444444......
...0000..0000...11.....11...22.....22......33......44..............
...00.0000.00...11.....11...22.....22......33......44..............
...00...0..00...11.....11...22222222.......33......44444...........
...00......00...111111111...2222...........33......44444...........
...00......00..11.......11..22.22..........33......44..............
...00......00..11.......11..22...2.........33......44..............
...00......00..11.......11..22....2......333333....4444444444......
...00......00.11.........11.22.....22..3333333333..4444444444..5...
...................................................................

*/

}

int		count_island(char *file)
{
	char	map[LIM] = {0};
	int		j;
	int		i;
	int		size;
	int		width;
	int		height;
	char	replacer;

	if (((j = open(file, O_RDONLY)) != -1) \
		&& ((size = read(j, map, LIM)) != -1))
	{
		// Cчитаем ширину карты используя первую строку файла
		width = 0;
		while (map[width++] != '\n');
		// Cчитаем высоту карты и проверяем наличие в ней лишних символов
		height = 0;
		i = -1;
		while (++i < size)
		{
			if (map[i] != '.' && map[i] != 'X' \
				&& map[i] != '\n' && map[i] != '\0')
				return (0);
			if (map[i] == '\n')
				height++;
		}
		// Проверяем размер карты
		if (height * width == size)
		{
			// запускаем цикл, который будет искать острова
			replacer = '0';
			i = -1;
			while (++i < height)
			{
				j = -1;
				while (++j < width)
				{
					if (map[(i * width) + j] == 'X')
						flood_fill(map, width, (i * width) + j, size, replacer++);
				}
			}
			/* Если количество найденых островов находиться в диапазоне 
			// ** от 1 до 10 то печатаем карту */
			if (replacer <= ('9' + 1))
				write(1, map, size - 1);
		}
	}
	return (0);
}

int		main(int ac, char **av)
{
	if (ac == 2)
		count_island(*(av + 1));
	write(1, "\n", 1);
	return (0);
}


/* ************************************************************************** */
/* ************************************************************************** */
/* ************************************************************************** */
/* ************************************************************************** */



#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>

void	ft_putstr(char *str)
{
	int i;

	i = 0;
	while (*(str + i))
		i++;
	write(1, str, i);
}

void	ft_putmap(char **map)
{
	int y;

	y = -1;
	while (map[++y])
		ft_putstr(map[y]);
}

int		ft_size(char *file, char c)
{
	int		fd;
	char	buffer;
	int		size;
	int		r;

	size = 0;
	if ((fd = open(file, O_RDONLY)) == -1)
		return (0);
	else
	{
		while ((r = read(fd, &buffer, 1)))
		{
			if (r == -1)
				break;
			if (buffer == c)
				break;
			size++;
		}
		if (close(fd) == -1)
			return (0);
	}
	return (size);
}

char	**file_to_arr(char *file)
{
	char	**map;
	int		fd;
	int		size;
	int		width;
	int		height;
	int		y;
	int		x;

	map = (void *)0;
	// Считаем размер файла с картой и ширину строки и количество строк.
	// И выделим память для указателей которые будут хранить адреса строк
	if ((size = ft_size(file, '\0')) &&	(width = ft_size(file, '\n') + 1) \
		&& (map = (char **)malloc(sizeof(char **) * ((size/ width) + 1))))
{
		// выделим память для каждой строки
		height = size / width;
		y = -1;
		while (++y < height)
		{
			if (!(map[y] = (char *)malloc(sizeof(char) * (width + 1))))
				return ((void *)0);
			map[y][width] = '\0';
		}
		// сохраняем карту в массив
		if (((fd = open(file, O_RDONLY))) == -1)
			return ((void *)0);
		y = -1;
		while (++y < height)
		{
			x = -1;
			while (((read(fd, &map[y][++x], 1)) != -1))
			{
				if (map[y][x] == '\n')
				{
					map[y][x + 1] = '\0';
					break;
				}
			}
		}
		if (close(fd) == -1)
			return ((void *)0);
		map[y] = (void *)0;
	}
	return (map);
}

void	floodfill(char **map, int x, int y, char c)
{
	if (y < 0 || x < 0 || !map[y] || !map[y][x] || map[y][x] != 'X')
		return ;
	map[y][x] = c;
	floodfill(map, x + 1, y, c);
	floodfill(map, x - 1, y, c);
	floodfill(map, x, y + 1, c);
	floodfill(map, x, y - 1, c);
}

void	count_island(char *file)
{
	char	**map;
	int		y;
	int		x;
	char	replace;

	// сохраняем карту в массив
	if ((map = file_to_arr(file)))
	{
		replace = '0';
		y = -1;
		// запускаем цикл, который будет искать в массиве острова
		while (map[++y])
		{
			x = -1;
			while (map[y][++x])
			{
				if (map[y][x] == 'X')
					floodfill(map, x, y, replace++);
			}
		}
		/* Если количество найденых островов находиться в диапазоне 
		** от 1 до 10 то печатаем карту */
		if (replace <= ('9' + 1))
			ft_putmap(map);
	}
	else
		ft_putstr("\n");
}

int		main(int ac, char **av)
{
	if (ac == 2)
		count_island(*(av + 1));
	return (0);
}
